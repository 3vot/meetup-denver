{
  "name": "clay-model",
  "description": "A Javascript Model Implementation with Promises based on SpineJS Model",
  "version": "0.0.4",
  "main": "./lib/index.js",
  "scripts": {
    "test": "tape test/*.js"
  },
  "author": {
    "name": "roberto@rodriguezartav"
  },
  "repository": "",
  "license": "BSD-2-Clause",
  "devDependencies": {
    "kew": "~0.5.0-alpha.1",
    "tape": "~2.4.0"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": [
      "ie/6..latest",
      "chrome/22..latest",
      "firefox/16..latest",
      "safari/latest",
      "opera/11.0..latest",
      "iphone/6",
      "ipad/6",
      "android-browser/latest"
    ]
  },
  "readme": "clay-model\n==========\n\nA Javascript Model Implementation with Promises based on SpineJS Model\n\n\nClass methods\n\n### Model.setup(modelName, attributes...)\n\nvar User = Model.setup(\"User\", [ \"first_name\", \"last_name\" ]);\n\nSet up the model and its attributes. This is required for every model, and should be called before anything else is.\n\n### Model.bind(eventName, function)\n\nBind event listeners to the model. These are executed in the context of the model.\n\nUser.bind(\"refresh change\", function(user){\n\talert(\"#{user.name} changed!\"))\n}\nSee events for more information.\n\n### Model.trigger(eventName, data...)\n\nTrigger a custom event, see events for more information.\n\n### Model.unbind([eventName, function])\n\nUnbind events, see the events guide for more information.\n\n### Model.find(id, [notFound])\n\nFind records by ID - returning the record instance. If the record doesn't exist, @notFound will be run unless a custom callback was also passed in.\n\nvar user = User.find(\"1\")\n\n### Model.exists(id)\n\nReturns a boolean indicating if the record with the specified ID exists or not.\n\nvar user = User.exists(\"1\")\n\n\n### Model.refresh(recordsArray, [options])\n\nAppends to all the stored records, without calling any create, update, save or destroy events. The only event that will be triggered is the refresh event. You can pass the option {clear: true} to wipe all the existing records. Internally @refresh calls fromJSON(), so you can also pass it JSON instead of an array.\n\nUser.refresh([{id: 1, name: \"test\"}, {id: 2, name: \"test2\"}])\n\n### Model.select(function)\n\nSelect all records that the callback function returns true to.\n\nbobs = User.select(function(user){ \n\treturn( user.name == \"bob\" );\n}\n\n### Model.findByAttribute(name, value)\n\nFind the first record that has the given attribute & value.\n\nbob = User.findByAttribute(\"name\", \"bob\")\n\n### Model.findAllByAttribute(name, value)\n\nFind all records that have the given attribute & value.\n\nbobs = User.findAllByAttribute(\"name\", \"bob\")\n\n### Model.each(callback)\n\nIterate over every record, passing it to the callback function.\n\nUser.each(function(user){\n\talert(user.name)\n});\n\n### Model.all()\n\nReturns a cloned copy of every instance.\n\nusers = User.all()\n\n### Model.slice(begin[, end])\n\nReturns a cloned copies of instances from begin up to but not including end.\n\nallUsersExceptFirst3 = User.slice(3)\nusers7through13 = User.slice(6,13)\n\n### Model.first([x])\n\nReturns a cloned copy of the first record. or an array of the first x records\n\n### Model.last([x])\n\nReturns a cloned copy of the last record, or an array of the last x records\n\n### Model.count()\n\nReturns the count of total records.\n\n### Model.deleteAll()\n\nDeletes every record without triggering any events.\n\n### Model.destroyAll(options)\n\nDestroys every record, triggering a destroy event on every record.\n\n### Model.update(id, attributes)\n\nUpdates the record with the matching ID, with the given attributes.\n\n### Model.create(attributes)\n\nCreates a new record with the given attributes. Returns false if the record's validation fails, or the newly created record if successful.\n\n### Model.destroy(id, options)\n\nDestroys the record with the given ID.\n\n### Model.toJSON()\n\nUtility function so the model has a valid JSON representation (shows all records).\n\n### Model.fromJSON(json)\n\nPass a JSON string, representing either an array or a singleton, to @fromJSON(). Returns an array or unsaved model instances.\n\n\n### Model.proxy(function)\n\nWrap a function in a proxy so it will always execute in the context of the model. This is a JavaScript compatibility feature, and shouldn't be used in CoffeeScript.\n\ncreate = Model.proxy(Model.create)\n\n### Model.setup\nModel.setup(name, [attributes...])\n\nAlternative method for creating a new model class. This is a JavaScript compatibility feature, and shouldn't be used in CoffeeScript.\n\nvar User = Model.setup(\"User\", [\"first_name\", \"last_name\"])\n\n\n## Instance methods\n\n### newRecord\n\nBoolean indicating if the record has been saved or not. Use isNew() instead.\n\n### isNew()\n\nReturns a boolean indicating if the record has been saved or not.\n\n### isValid()\n\nReturns a boolean indicating if the record has passed validation.\n\n### validate()\n\nBy default a noop. Override this to provide custom validation. Return a string, containing the error message, if the record isn't valid. For example:\n\n\n  Model.prototype.validate = function(){\n    \"Name required\" unless @name\n  }\n\n### load(attributes)\n\nLoad a set of properties in, setting attributes.\n\nuser = new User\nuser.load(name: \"Sir Bob\")\nattributes()\n\nReturns a hash of attributes to values.\n\n### eql(record)\n\nReturns a boolean indicating if the other record is equal (i.e. same class and ID) as the current instance.\n\nif(user.eql(anotherUser)) alert(\"Yah!\")\n\n### save()\n\nCreates or updates the record, returning false if the record's validation fails, or self if the record saves successfully. During a save, the beforeSave, change and save events are triggered. Also the create or update events will be fired depending on whether the record was created/updated.\n\nuser = new User(name: \"Sir Robin\")\nuser.save()\n\nalert(\"#{user.id} was saved\")\nuser = User.find(user.id)\n\n### updateAttribute(name, value)\n\nSets a single attribute, saving the instance.\n\nuser = new User\nuser.updateAttribute(\"name\", \"Green Knight\")\n\n### updateAttributes(attributes)\n\nUpdates a record with the given attributes, saving the record.\n\nuser = User.create()\nuser.updateAttributes(name: \"Sir Galahad the Pure\")\n\n### destroy()\n\nDestroys the record, removing it from the record store and triggering the destroy event.\n\nuser = User.create()\n\n### user.destroy()\nDestroy will also unbind event listeners for the model and objects it was listening to.\n\n### dup()\n\nReturns a new unsaved record, with the same attributes as the current record, save the ID, which will be null.\n\nuser = User.create(name: \"Sir Bedevere\")\ndup  = user.dup()\nassertEqual( dup.name, \"Sir Bedevere\" )\n\nReturns a prototype clone of the record. This is used internally for Dynamic Records, and is probably not something you need to worry about.\n\n### clone()\n\nReturns a prototype clone of the record. This is used internally for Dynamic Records, and is probably not something you need to worry about.\n\n### reload()\n\nReloads a record's attributes from its saved counterpart.\n\n### toJSON()\n\nReturns the record's attributes. This is used for JSON serialization:\n\nrecord = new User(name: \"Sir Lancelot the Brave\")\n\nassertEqual( JSON.stringify(record), '{\"id\":\"foo\",\"name\":\"Sir Lancelot the Brave\"}' )\n\n$.post(\"/record.json\", JSON.stringify(record))\n\n### toString()\n\nReturns a string representation of the record. A utility function used to display the record in the console.\n\n### exists()\n\nReturns a boolean indicating whether the record has saved. Similar to isNew(), but it actually checks the models record store.\n\n### bind(name, function)\n\nBind to an event specifically on this record. on is an available alias.\n\n### trigger(name, [data...])\n\nTrigger an event specifically on this record. This will propagate up to the model too.\n\n### unbind([events, callback])\n\nUnbind all events, or just certain events (as a comma seperated list), or a specific callback for given events. off is an available alias\n\n### proxy(function)\n\nA JavaScript compatibility function, that will wrap the given function so that it's always executed in the context of the record.\n\n\n## Ajax\n\nModel comes with an interface for Ajax or other connectors. Define the connector after creating the model with \n\nModel.ajax = AjaxConnector;\n\nYou can find a reference of a Connector in clay-model-vfr\n\nModel.create( values, options ), modelInstance.save( options ) and modelInstance.destroy(options)\n\nAll take an options argument, here are some values\n\nignoreAjax: [true/false]: Will only make modifications locally without sending changes to the server.\n\n\n## API\n\nUsed to execute custom API Calls, is defined by Ajax Connector\n\n```\nUser.api( arguments... );\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "clay-model@0.0.4",
  "_from": "clay-model@"
}
